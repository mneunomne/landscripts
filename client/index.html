<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Image Zoom and Smooth Camera Movement</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}

		#canvas {
			display: block;
		}
	</style>
</head>

<body>
	<canvas id="canvas"></canvas>
	<script>
		const imgWidth = 5083;
		const imgHeight = 5090;

		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');

		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		const img = new Image();
		img.src = './image.jpg'; // Provide the path to your large image

		const points = []; // Array to store all the received points

		let zoomLevel = 0.8; // Set to 50% zoom
		let cameraX = imgWidth / 2; // Initial camera position (center of the image)
		let cameraY = imgHeight / 2;

		const easing = 0.05; // Easing factor for smooth movement

		img.onload = function () {
			// When the image loads, draw it initially
			drawScene(); // Initial draw
		};

		// Connect to the WebSocket server
		const socket = new WebSocket('ws://localhost:8080/');

		// When a message is received from the server
		socket.onmessage = function (event) {
			const position = JSON.parse(event.data);
			addPoint(position.x, position.y);
		};

		function addPoint(x, y) {
			// Map position from [0, 1000] to [0, 5090]
			const mappedX = map(x, 0, 1000, 0, imgWidth);
			const mappedY = map(y, 0, 1000, 0, imgHeight);

			// Add the mapped position to the points array
			points.push({ x: mappedX, y: mappedY });
		}

		function drawScene() {
			// Calculate zoomed image dimensions
			const zoomedWidth = imgWidth * zoomLevel;
			const zoomedHeight = imgHeight * zoomLevel;

			if (points.length > 0) {
				const lastPoint = points[points.length - 1];

				// Smoothly move camera towards the last point using linear interpolation (lerp)
				cameraX = lerp(cameraX, lastPoint.x, easing);
				cameraY = lerp(cameraY, lastPoint.y, easing);

				// Ensure camera doesn't go out of bounds
				const halfCanvasWidth = canvas.width / 2;
				const halfCanvasHeight = canvas.height / 2;
				cameraX = Math.max(halfCanvasWidth / zoomLevel, Math.min(imgWidth - halfCanvasWidth / zoomLevel, cameraX));
				cameraY = Math.max(halfCanvasHeight / zoomLevel, Math.min(imgHeight - halfCanvasHeight / zoomLevel, cameraY));

				// Calculate offsets to center the camera on the cameraX, cameraY position
				const offsetX = canvas.width / 2 - cameraX * zoomLevel;
				const offsetY = canvas.height / 2 - cameraY * zoomLevel;

				// Clear the canvas
				ctx.clearRect(0, 0, canvas.width, canvas.height);

				// Draw the zoomed image centered on the camera position
				ctx.drawImage(img, offsetX, offsetY, zoomedWidth, zoomedHeight);

				// Draw the lines connecting all the points
				ctx.beginPath();
				ctx.strokeStyle = 'red';
				ctx.lineWidth = 2;

				// Loop through the points and draw lines connecting them
				for (let i = 0; i < points.length; i++) {
					const px = offsetX + points[i].x * zoomLevel;
					const py = offsetY + points[i].y * zoomLevel;
					if (i === 0) {
						ctx.moveTo(px, py);
					} else {
						ctx.lineTo(px, py);
					}
				}

				ctx.stroke();
			}

			// Request animation frame for smooth drawing
			requestAnimationFrame(drawScene);
		}

		// Mapping function
		function map(value, start1, stop1, start2, stop2) {
			return ((value - start1) / (stop1 - start1)) * (stop2 - start2) + start2;
		}

		// Linear interpolation function
		function lerp(start, end, t) {
			return start + (end - start) * t;
		}

		// Start the initial draw
		drawScene();
	</script>
</body>

</html>